/**
 * Define a grammar called Expressions
 */
grammar OFP;

@header {    // Define name of package for generated Java files. 
    package generated;
}

// Syntax Specification ==> Context-free Grammar
start: methodFunc* mainFunc methodFunc*;

mainFunc: 'void' 'main' paramList '{' stmt* '}';

methodFunc: TYPE ID paramList stmtBlock;

// common blocks
stmtBlock: stmt | '{' stmt* '}';
paramList: '(' (TYPE ID (',' TYPE ID)*)? ')';
exprList: expr (',' expr)*; // could add ( '(' | '}' )

stmt:
	assign
	| TYPE ID ';'
	| arrayAcces
	| arrayAssign
	| 'if' expr stmtBlock ('else' (stmt | stmtBlock))?
	| 'while' expr stmtBlock
	| 'return' expr ';'
	| methodCall
	| print;

expr:
	'(' expr ')'								# parenthesis
	| '-' expr									# negation
	| expr ('*' | '/') expr						# multdiv
	| expr ('+' | '-') expr						# addsub
	| expr ('>' | '<' | '==') expr				# comp
	| (INT | FLOAT | BOOL | ID | STRING | CHAR)	# literal
	| expr '[' expr ']'							# arrayAccess
	| expr '.length'							# length
	| 'new' TYPE '[' expr ']'					# newArray
	| methodCall								# callMethod;

// stmt
print: ('print' | 'println') '(' expr ')' ';';

assign: TYPE? ID '=' expr ';';
arrayAcces: ID '[' expr ']' '=' expr ';';
arrayAssign: TYPE? ID '=' '{' exprList? '}' ';';

methodCall: ID '(' (expr (',' expr)*)? ')' ';'?;

// Lexer Specification ==> Regular Expressions Only non-trivial expressions. Trivial token
// definitions are hard coded in grammar.
INT: '0' | [1-9][0-9]*;
FLOAT: '0' '.' [0-9]+ | [1-9] [0-9]* '.' [0-9]+;
BOOL: 'true' | 'false';
ID: [a-zA-Z] [a-zA-Z0-9_]*; // cant be _hello
// stirng and char by AI
STRING: '"' [a-zA-Z!.,?=:() ]* '"';
CHAR: '\'' [a-zA-Z!.,?=:() ] '\'';
WS: [ \t\r\n]+ -> skip;

// is there a way to esacpe the empty space trailing the type? yes, add WS
TYPE:
	' '? (
		'int'
		| 'float'
		| 'bool'
		| 'char'
		| 'string'
		| 'int[]'
		| 'float[]'
		| 'bool[]'
		| 'char[]'
		| 'string[]'
	) ' '?;

// line below generated by AI
COMMENT: '#' (~[\r\n])* -> skip;